<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Not/Empty</title><link href="https://thomas.spurden.name/" rel="alternate"></link><link href="https://thomas.spurden.name/feeds/all.atom.xml" rel="self"></link><id>https://thomas.spurden.name/</id><updated>2019-07-18T00:00:00+01:00</updated><entry><title>Building a custom keyboard</title><link href="https://thomas.spurden.name/building-a-custom-keyboard.html" rel="alternate"></link><published>2019-07-18T00:00:00+01:00</published><updated>2019-07-18T00:00:00+01:00</updated><author><name>Thomas Spurden</name></author><id>tag:thomas.spurden.name,2019-07-18:/building-a-custom-keyboard.html</id><summary type="html">&lt;p&gt;I made a custom keyboard design, the &lt;a class="reference external" href="https://github.com/tcrs/ergosnap"&gt;ErgoSnap&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="Final constructed ErgoSnap rev1.1 board" src="https://thomas.spurden.name/images/ergosnap_v1.1.jpg" /&gt;
&lt;div class="section" id="backstory"&gt;
&lt;h2&gt;Backstory&lt;/h2&gt;
&lt;p&gt;A while ago I built an &lt;a class="reference external" href="https://keeb.io/products/iris-keyboard-split-ergonomic-keyboard"&gt;Iris keyboard&lt;/a&gt; from a kit because I wanted to try a
split layout. I'm pretty happy with it but after using it for a few months
decided I would like a few more keys. I …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I made a custom keyboard design, the &lt;a class="reference external" href="https://github.com/tcrs/ergosnap"&gt;ErgoSnap&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="Final constructed ErgoSnap rev1.1 board" src="https://thomas.spurden.name/images/ergosnap_v1.1.jpg" /&gt;
&lt;div class="section" id="backstory"&gt;
&lt;h2&gt;Backstory&lt;/h2&gt;
&lt;p&gt;A while ago I built an &lt;a class="reference external" href="https://keeb.io/products/iris-keyboard-split-ergonomic-keyboard"&gt;Iris keyboard&lt;/a&gt; from a kit because I wanted to try a
split layout. I'm pretty happy with it but after using it for a few months
decided I would like a few more keys. I had a look at what else was available,
and after spending a lot of time on the internet decided that the layout of the
&lt;a class="reference external" href="https://github.com/omkbd/ErgoDash"&gt;ErgoDash&lt;/a&gt; looked good. I liked the construction of the &lt;a class="reference external" href="https://github.com/reversebias/mitosis-hardware"&gt;Mitosis&lt;/a&gt; using a single
PCB design for both the mounting plate and the actual PCB the switches are
soldered to; however I didn't want a wireless keyboard and wanted to stick with
the &lt;a class="reference external" href="https://qmk.fm/"&gt;QMK&lt;/a&gt; firmware. So I decided to adapt the ErgoDash design to use the Mitosis
construction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="construction"&gt;
&lt;h2&gt;Construction&lt;/h2&gt;
&lt;p&gt;Since I was designing my own keyboard I can tailor it to my requirements:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Tenting built in. Just need two M6 mounting holes on the inside edge of the board&lt;/li&gt;
&lt;li&gt;Don't care about any kind of lighting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I chose to use the diode mounting holes in the keyswitches - these are wider
than the LED mounting holes (but in the same location on the keyswitch). They
are in the Cherry MX &lt;a class="reference external" href="http://switches-sensors.zf.com/wp-content/uploads/2012/07/Keymodule_MX_EN.pdf"&gt;datasheet&lt;/a&gt; (found by searching around on the internet). I'm
using &lt;a class="reference external" href="https://zealpc.net/products/zealio"&gt;Zealios&lt;/a&gt; and the ones I've got definitely have the diode holes. This
simplified routing as the diode overlaps the switch.&lt;/p&gt;
&lt;p&gt;I created a custom component and footprint with the keyswitch, diode and cutouts
for snapout section (for the mounting plate PCB). Added a chin at the top for
the ProMicro, used the reversible ProMicro footprint from &lt;a class="reference external" href="https://github.com/Biacco42/Ergo42"&gt;Ergo42&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ordered PCBs from JLC PCB:&lt;/p&gt;
&lt;img alt="Top view of both halves of the revision 1 ErgoSnap PCB" src="https://thomas.spurden.name/images/keyboard-rev1-top-both.jpg" /&gt;
&lt;img alt="Side view of stacked Rev 1 ErgoSnap PCB with a couple of keyswitches" src="https://thomas.spurden.name/images/keyboard-rev1-side-view.jpg" /&gt;
&lt;p&gt;First set of PCBs arrived and looked good, but...&lt;/p&gt;
&lt;img alt="Closeup of keyswitch and PCB showing misaligned holes for diode legs" src="https://thomas.spurden.name/images/keyboard-rev1-diode-holes.jpg" /&gt;
&lt;p&gt;the holes for the diode legs were not the right distance apart! Whoops. Luckily
PCBs are pretty cheap so a couple of weeks later I had revised boards. Only a
few mistakes remain now. See the &lt;a class="reference external" href="https://github.com/tcrs/ergosnap"&gt;ErgoSnap&lt;/a&gt; github repo for more info.&lt;/p&gt;
&lt;/div&gt;
</content></entry><entry><title>STM32 Getting Started</title><link href="https://thomas.spurden.name/stm32-getting-started.html" rel="alternate"></link><published>2018-02-28T00:00:00+00:00</published><updated>2018-02-28T00:00:00+00:00</updated><author><name>Thomas Spurden</name></author><id>tag:thomas.spurden.name,2018-02-28:/stm32-getting-started.html</id><summary type="html">&lt;p&gt;See &lt;a href="https://github.com/tcrs/stm-start"&gt;this GitHub repo&lt;/a&gt; for the related code
(and a copy of this post).&lt;/p&gt;
&lt;h1&gt;Getting Started using the STM32 platform&lt;/h1&gt;
&lt;p&gt;I have an &lt;a href="http://wiki.seeedstudio.com/wiki/Arch_Max"&gt;Arch Max&lt;/a&gt; STM32F4 development board. Although it &lt;a href="https://developer.mbed.org/platforms/Seeed-Arch-Max/"&gt;supports
mbed&lt;/a&gt; I like to understand how things work...&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://www.st.com/resource/en/datasheet/dm00037051.pdf"&gt;datasheet&lt;/a&gt; and &lt;a href="http://www.st.com/resource/en/reference_manual/dm00031020.pdf"&gt;reference manual&lt;/a&gt; have all the required
low-level hardware …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See &lt;a href="https://github.com/tcrs/stm-start"&gt;this GitHub repo&lt;/a&gt; for the related code
(and a copy of this post).&lt;/p&gt;
&lt;h1&gt;Getting Started using the STM32 platform&lt;/h1&gt;
&lt;p&gt;I have an &lt;a href="http://wiki.seeedstudio.com/wiki/Arch_Max"&gt;Arch Max&lt;/a&gt; STM32F4 development board. Although it &lt;a href="https://developer.mbed.org/platforms/Seeed-Arch-Max/"&gt;supports
mbed&lt;/a&gt; I like to understand how things work...&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://www.st.com/resource/en/datasheet/dm00037051.pdf"&gt;datasheet&lt;/a&gt; and &lt;a href="http://www.st.com/resource/en/reference_manual/dm00031020.pdf"&gt;reference manual&lt;/a&gt; have all the required
low-level hardware info. This guide will get you started compiling C programs to
directly twiddle with the stuff from the reference manual.&lt;/p&gt;
&lt;p&gt;I experimented with two ways to get started on the board: CMSIS and libopencm3.
I preferred libopencm3 and that's what I'm using now, but have included examples
using both. The toolchain and debugging stuff is the same between the two.&lt;/p&gt;
&lt;h2&gt;Toolchain&lt;/h2&gt;
&lt;p&gt;On Arch Linux, just install the &lt;code&gt;arm-none-eabi-gcc&lt;/code&gt; and &lt;code&gt;arm-none-eabi-newlib&lt;/code&gt;
packages. Most other distros probably offer similarly named packages.&lt;/p&gt;
&lt;h1&gt;OpenOCD&lt;/h1&gt;
&lt;p&gt;An &lt;code&gt;openocd&lt;/code&gt; config file is provided in the &lt;a href="https://github.com/Seeed-Studio/Arch_Max.git"&gt;Arch Max git repo&lt;/a&gt;.
Then running &lt;code&gt;openocd -f Arch_Max/arch_max.cfg&lt;/code&gt; with the board connected to a
USB port should pick it up and provide a GDB server on port &lt;code&gt;3333&lt;/code&gt;. I have to
run OpenOCD as root as it needs access to the &lt;code&gt;/dev/hidraw0&lt;/code&gt; device node to
communicate with the board.&lt;/p&gt;
&lt;h1&gt;GDB&lt;/h1&gt;
&lt;p&gt;Once OpenOCD is running and connected to the board via USB &lt;code&gt;gdb&lt;/code&gt; can be
connected and used to run and debug binaries. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;arm&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;none&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eabi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;load&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt; &lt;span class="nb"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The gdb script &lt;code&gt;load.gdb&lt;/code&gt; will connect to the OpenOCD gdb server, reset the
board and load the elf file into memory. You can continue (&lt;code&gt;c&lt;/code&gt;) at the GDB
prompt to just run the program. For debugging you can set breakpoints etc before
running too.&lt;/p&gt;
&lt;p&gt;TOOD:
 - how to program an image into flash&lt;/p&gt;
&lt;h1&gt;Examples&lt;/h1&gt;
&lt;p&gt;Both the libopencm3 and the CMSIS examples will produce a binary which when run
on the Arch Max board will blink the LED next to the ethernet port (GPIO B3).&lt;/p&gt;
&lt;p&gt;The Makefiles in both examples will link an elf executable file, which is
suitable for debugging and loading via GDB (see above). A further &lt;code&gt;objcopy -O
binary&lt;/code&gt; step (also shown in the Makefiles) provides a file suitable for flashing
onto the chip's flash memory (I think - I've not got around to actually trying
this yet!).&lt;/p&gt;
&lt;h2&gt;Using libopencm3&lt;/h2&gt;
&lt;p&gt;The &lt;a href="http://libopencm3.org/"&gt;libopencm3&lt;/a&gt; project provide an free software library which is
in many ways similar to CMSIS, but I found it easier to get started with and it
is what I use for projects now. Note that despite the name it also supports a
large range of Cortex-M4 devices!&lt;/p&gt;
&lt;p&gt;There is an awk script (&lt;code&gt;libopencm3/scripts/gnlink.awk&lt;/code&gt;) which can generate the
required C flags and linker script for a device, see
&lt;code&gt;example-libopencm3/Makefile&lt;/code&gt; for usage.&lt;/p&gt;
&lt;p&gt;The generated linker script sets the executable entry point to &lt;code&gt;reset_handler&lt;/code&gt;
which can be found in &lt;code&gt;libopencm3/lib/cm3/vector.c&lt;/code&gt;. This is pretty minimal:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clears the BSS&lt;/li&gt;
&lt;li&gt;makes sure the stack is aligned correctly&lt;/li&gt;
&lt;li&gt;calls pre_main, which may do chip-specific init. For the STM32F4 boards it
   just enabled access to the floating point unit&lt;/li&gt;
&lt;li&gt;calls global constructors&lt;/li&gt;
&lt;li&gt;calls main() - provided by you!&lt;/li&gt;
&lt;li&gt;calls global destructors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that the clocks are left in their reset state. In the example I have
set them up (using the &lt;code&gt;rcc_clock_setup_hse_3v3&lt;/code&gt; function) to run at 168MHz. The
settings there are correct for the Arch Max (I hope!) as it has a high-speed
external (hse) 8MHz oscillator.&lt;/p&gt;
&lt;p&gt;Using the functions in libopencm3 to do simple things like toggling the GPIO is
probably rather wasteful as they each incur a function call overhead. If you are
worried about this then you can build the libopencm3 library and your binary
with link-time optimisation (LTO), which will inline any small functions the
compiler thinks is wise.&lt;/p&gt;
&lt;h2&gt;Using CMSIS&lt;/h2&gt;
&lt;p&gt;I found it very difficult to find the CMSIS code. It turns out the best way to
get hold of it for a platform with mbed support (which is quite a lot, including
the Arch Max) is to just grab the mbed source code from &lt;a href="https://github.com/ARMmbed/mbed-os.git"&gt;mbed-os GitHub
repo&lt;/a&gt;. The repository contains lots of stuff for mbed and mbed-os, but the
interesting CMSIS code is in the &lt;code&gt;targets&lt;/code&gt; folder.&lt;/p&gt;
&lt;p&gt;Each supported chip has a folder containing a chip-specific startup assembly
file. For the Arch Max this is in &lt;code&gt;mbed-os/targets/TARGET_STM/TARGET_STM32F4/TARGET_STM32F407xG/device/TOOLCHAIN_GCC_ARM/startup_stm32f407xx.S&lt;/code&gt;
This assembly file contains the entry point (&lt;code&gt;Reset_Handler&lt;/code&gt;) and quite well
documented with comments - it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sets up the stack&lt;/li&gt;
&lt;li&gt;Copies data segment from flash to RAM&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;SystemInit&lt;/code&gt; to init clock and other basic hardware init&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;_start&lt;/code&gt; (which is the libc entry point that will call main)&lt;/li&gt;
&lt;li&gt;Provides the interrupt vector table&lt;/li&gt;
&lt;li&gt;Default handler just enters an infinite loop&lt;/li&gt;
&lt;li&gt;Set up to have a weak symbol for each interrupt, aliased to the default one&lt;/li&gt;
&lt;li&gt;Can easily provide an interrupt handler by just creating a function of the
     correct name (e.g. &lt;code&gt;EXTI0_IRQHandler&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the same folder as the startup &lt;code&gt;.S&lt;/code&gt; file there should be a linker script
(&lt;code&gt;.ld&lt;/code&gt;) which should be passed to the linker with the &lt;code&gt;-T&lt;/code&gt; option. This is also
quite well commented.&lt;/p&gt;
&lt;p&gt;An implementation of &lt;code&gt;SystemInit&lt;/code&gt; for the Arch Max is provided
(&lt;code&gt;mbed-os/targets/TARGET_STM/TARGET_STM32F4/TARGET_STM32F407xG/TARGET_ARCH_MAX/system_stm32f4xx.c&lt;/code&gt;)
which sets up the system clock and various other bits and bobs. This
implementation calls into the HAL library (sources for which can be found at
&lt;code&gt;mbed-os/targets/TARGET_STM/TARGET_STM32F4/device/&lt;/code&gt;). I have provided a chopped
down version &lt;code&gt;system_light.c&lt;/code&gt; which does not depend on the HAL library.&lt;/p&gt;
&lt;p&gt;The mbed files for your board should have some clues as to what pins are
connected to the odd LEDs etc. which are probably on your board. For the Arch
Max that was in
&lt;code&gt;mbed-os/targets/TARGET_STM/TARGET_STM32F4/TARGET_STM32F407xG/TARGET_ARCH_MAX/PinNames.h&lt;/code&gt;
- at the bottom &lt;code&gt;LED1&lt;/code&gt; is set to &lt;code&gt;PB_3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The provided &lt;code&gt;Makefile&lt;/code&gt; shows the compiler/linker options and include paths required.&lt;/p&gt;
&lt;p&gt;See example in the &lt;code&gt;example-cmsis&lt;/code&gt; folder (note you'll need that checkout of
&lt;code&gt;mbed-os&lt;/code&gt; - see the readme in the folder).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sergeev.io/notes/cortex_cmsis/"&gt;Good overview of CMSIS on the LPC devices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://regalis.com.pl/en/arm-cortex-stm32-gnulinux/"&gt;Very useful tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jeremyherbert.net/get/stm32f4_getting_started"&gt;Useful tutorial on making a blinky&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://theanine.io/notes/cortex_cmsis/"&gt;Tutorial not really checked out yet&lt;/a&gt;&lt;/p&gt;</content></entry></feed>